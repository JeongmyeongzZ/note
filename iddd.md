# IDDD (Implementing domain-driven design) 도메인 주도 개발 설계 구현


## 1. DDD를 시작하며

도메인 전문가는 직책이 아니다. 비즈니스 도메인에 대해 배경지식을 많이 갖고 있는 디자이너거나 영업 인력일 수도 있다. 개발자는 듣을 줄 아는 능력이 필요하다.

도메인 모델이란 구체적인 비즈니스 도메인에 관한 소프트웨어 모델이다. 객체 모델로 종종 구현되는데, 의미를 정확히 부합하는 이름과 데이터, 행동을 담고있다.

DDD 는 비즈니스 전문가 (도메인 전문가) 와 개발자간의 심적 모델을 반영해 개발할 수 있게 해준다. 함께 유비쿼터스 언어를 비즈니스 영역에 적용하며 개발하는 데 힘 쓴다. 초기 비용이 많이들지만 잘 짜여진 팀을 만들고 이는 더욱 팀을 강하게 한다. 비즈니스의 이니셔티브를 다룬다. 기술 분석이 전혀 관련없을 수 없지만 비즈니스의 전략적 설계와 더 가깝다.

* 복잡화하지말고 단순화하자* 이 것이 중요하다. 무기력증으로 인한 기억력 상실 (anemia-induced memory loss) 증상을 겪기 쉽상이다.

수정도, 저장도 맡고 있는 인터페이스를 예로 들어보자. 어떤 값이 변해서 이 인터페이스에 들어왔는지, 수정을 위해서인지 저장을 위해서인지 인터페이스를 통해 알 수 있는 의도가 거의 없다. 이 인터페이스에서 어떤 값이 변했을 때에 대한 조건이 점점 늘어난다면, 복잡도만 점점 늘어날 것이다. 그리고 무엇보다 해당 객체(수정 및 저장 대상)가 사실 전혀 객체가 아니다. 단순 데이터 홀더 정도라고 볼 수 있다.

이는 하나의 메서드(인터페이스) 에서 많은 유즈케이스 플로우나 사용자 스토리를 처리한다. 하나의 ㅐ플리케이션 서비스 메소드가 하나의 유즈케이스만을 위해서 구현되면 어떨까 ?

더 정교하고, 정확하게 비즈니스를 정희하고 이해할 수 있지 않은가? 
더 유요한 도메인 모델을 얻을 수 있지 않은가?

모델 객체를 위해 데이터 접근자만을 노출 시킨다면 그 결과는 단순한 데이터 모델에 가깝게 된다. 데이터 관점의 설계, 게터 및 세터의 무분별한 사용은 도메인 모델을 해친다. 아니, 전혀 도메인 모델이 아니다. 이는 전적으로 클라이언트가 사용방법을 알고 있는지에 달려있다. (유즈케이스가 명확하지 않기때문) 정확한 값을 데이터 모델에 매핑하기 위해 분석을 해야한다. 도메인 비즈니스 가치가 하나도 없다. 그리고 본인도 모르는 사이 너무 많은 선택가능한 옵션을 만들게 된다.

---

## 2. 도메인, 서브도메인, 바운디드 컨텍스트

도메인은 비즈니스의 전체도메인을 말할 수도 있고, 한가지 핵심부분이나 다른 지원분야일 수도 있다. 도메인 모델이란 용어도 도메인이란 용어가 들어있으니 조직의 전체 비즈니스 도메인을 위한 모델이라고 생각할 수 있지만, DDD 에서의 도메인 모델은 오히려 그 반대이다. 조직의 전체 비즈니스 도메인은 여러 서브 도메인으로 이루어져있다. 모델은 바운디드 컨텍스트 안에서 만들어진다. 이 서브도메인은 고유의 핵심 도메인의 일부가 아닌, 일련의 알고리즘과 같은 간단한 형태일 수도 있다.

바운디드 컨텍스트는 주로 유비쿼터스 언어와 그에 해당하는 도메인 모델을 캡슐화한다. ( 도메인 모델과 상호작용, 도메인 모델의 지원을 위해 존재하는 다른 요소도 포함한다. )
모듈, 애그리게잇, 이벤트, 서비스 등 충분할 만큼 포함할 정도로 커야 함.

DDD 에 익숙하지 않은 개발자(나와 같은) 기준에선, 프로젝트 하나의 단위라고 생각하면 좋을 것 같다.
presentation, application, domain(model), infrastructure 의 한 모듈이 하나의 바운디드 컨텍스트, 하나의 팀이 작업해야하는 단위인 것이다.

---

## 3. 컨텍스트 맵

컨텍스트 맵은 바운디드 컨텍스트들 사이의 매핑을 보여주는 단순 다이어그램을 그리는 거라고 볼 수 있다. 이는 엔터프라이즈 아키텍처나 시스템 위상 다이어그램이 아니다. 조직 역학(organizational dynamic)을 보여주는 것이다. 통합의 병목, 아키텍처적 결핍을 강조할 수 있으며, 진행에 걸림돌이 되는 끈적거리는 거버넌스 이슈나 여러 문제를 밝히는 데 도움이 될 수 있다.

adapter, translator(로컬 시스템의 개념으로 변환, 값 객체 및 엔티티로 변환), moderator(xml to json 등 변환) 를 활용한 부패 방지계층 (anticorruption layer, ACL)을 통해 업스트림과 다운스트림의 연결
- REST 기반의 리소스로 구현
- RPC(Remote Procedure Call) API (원격에 위치한 프로그램을 로컬에 있는 프로그램처럼 사용할 수 있다. 개발자는 network 통신과 관련된 작업은 신경쓰지 않아도 된다.)
- 메시지 교환 (MQ 등)

---

## 4. 아키텍처

DDD 는 사실 특정 아키텍처의 사용을 요구하지 않는다. 이게 가장 큰 장점 중 하나라고 한다..

무엇이든 규모에 맞는 아키텍처가 제일 중요하다. 다만 책에 나온 사스오베이션의 일화를 보면 확장성 있게 코드베이스를 다지고, 그를 기반으로 아키텍처를 변화시키면 될 것 같다. CQRS, event sourcing, Hexagonal .. 등등

- 전통적인 DDD 계층 아키텍처 <UI(presentation) - Application - Domain - Infrastructure>
  - 바로 아래층과만 연결되도록 하는 엄격한 (strict) 계층도 있지만 보통 어플리케이션과 UI에서 인프라계층을 이용하기 때문에 느슨한 (relaxed) 계층을 기반으로 한다
  - DIP 의 활용
  - 도메인 로직이 애플리케이션 서비스로 새어나가지 않아야함. 모델이 무력해지면 안됨
- 헥사고날 또는 포트와 어댑터
  - 대부분의 계층형 아키텍처를 사용하는 곳에서 헥사고날이 녹아있다. DIP 의 사용이기때문에 포트 어댑터 스타일의 방향으로 흘러가는 것
  - 프론트엔드와 백엔드라고 여기는 게 아닌 다른 방식으로 바라본다. 각 클라이언트 타입<HTTP, AMQP(rabbit mq 와 같은)>이 자신의 고유한 어댑터를 갖는다. 이 어댑터가 애플리케이션과 호환되는 내부 입력으로 변환한다
- 서비스 지향 
- CQRS
  - DomainEventPublisher (옵저버 패턴에 기반한 경량 컴포넌트)
- 파이프와 필터 패턴, 이벤트 소싱 등 이벤트 주도 방식

---

## 5. 엔티티

개발자는 도메인보다 데이터에 초점을 맞추려는 경향이 있다. 대부분 데이터베이스 중점으로 사고하기때문에 DDD 를 처음 경험하는 개발자에겐 흔히 일어날 수 있는 현상이다.

유비쿼터스 언어를 활용해 행동을 끌어내야한다. 행동을 먼저 정의하고 그를 통해 연결관계를 이끌어내자. 너무 구체적이지 않은 상태를 바탕으로 관계를 통해 객체를 모델링하자.

식별자를 찾아내자. (대리식별자: 기본적인 auto increment PK. id, no 따위의 컬럼) 도메인 식별자가 굳이 기본키가 될 필요는 없다. 두 값이 합쳐진 복합 유니크 키와 같은 형태도 될 수 있다.
식별자가 값 객체로 모델링 되는 이유는 단순 String (UUID) 따위의 문자 표현일지라도 광범위하게 사용될 수 있기 때문이다. 더 강한 타입으로 지정한다는 의미이다.

(좀 더 작은 단위로 역할 인터페이스를 만드는 방법도 고려해보자)

엔티티를 생성시엔 팩토리를 사용해보자.
엔티티 생성시 유효성 검사등은 Validator 클래스등을 명세패턴이나 전략패턴을 통해 구현하자. (Base Entity class 에 validate 메서드를 overide 하고, 유효성 검사 명세를 파라미터로 넘겨주는 등)

도메인 엔티티에 대한 변경사항 추적은 도메인 이벤트와 이벤트 저장소를 통해 확인하자. (이벤트소싱과 같은 패턴을 통해)

---

## 6. 값 객체


엔티티에 대한 고민에 가려지지만, 값 객체는 DDD 에 필수 구성요소다. 값 타입을 생성하는 일은 쉽지만, DDD에 경험이 없다면 특정 인스턴스 내에서 엔티티로 모델링할지, 값으로 모델링할지는 상당히 혼란스러울 수 있다.

_특징_

- 도메인 내의 어떤 대상을 측정하고 수량화하고 설명한다.
  - 값 객체는 도메인 안에 있지 않다.  이는 도메인 내에 있는 어떤 대상을 측정하고 수량화하고 설명하는 개념이다. 사람에겐 나이와 이름이 있다. 이는 실재하지 않지만 측정하고 수량화하며 이를 설명한다.
  - 개념적 전체
- 불변성
  - 생성되면 변경할 수 없다.
- 관련 특성을 모은 필수 단위로 개념적 전체를 모델링한다.
  - 응집력 
- 측정이나 설명이 변경될 땐 완벽히 대체 가능하다.
  - 불변성, 새 객체 
- 다른 값과 등가성을 사용해 비교할 수 있다.
  - equals(), hashCode() 
- 협력자에게 부작용이 없는 행동을 제공한다.
  - 값 객체에 변화를 주지 않는 함수는 가질 수 있다.

---

## 7. 서비스

도메인 내에서 서비스란 도메인 고유의 작업을 수행하는 무상태의 오퍼레이션이다. 서비스가 필요하다는 지표는 애그리게잇이나 값 객체 상에서 수행해야하는 오퍼레이션이 메소드로는 부적절하다고 느껴질때다.

도메인 서비스와 애플리케이션 서비스를 혼동해서는 안 된다.

---

## 8. 도메인 이벤트

중요한 일이 발생했기 때문에 알림을 받기를 원하고 있다는 것은 명시적인 이벤트를 모델링해야 할 여지가 크다는 의미다.

그런 일이 일어나면 중요하지 않지만, 일언 일이 일어나면 중요해요. 라는 말이 될 수도, 조직 문화에 따라 다른 중요한 문구가 될 수도 있다.

이런 상황은 이벤트를 외부의 서비스로 브로드캐스트 해야할 때 주로 일어나는데, 이는 엔터프라이즈 시스템을 결합에서 분리해야하고, 도메인 전반에 걸쳐 일어난 사건은 바운디드 컨텍스트 전체로 전달돼야 한다.

에그리게잇 규칙중에는 트랜잭션에서 단 하나의 인스턴스만이 변경돼야 하고, 다른 모든 종속적 변경은 별도의 트랜잭션에서 일어나야 한다는 규칙이 있다.

따라서 이 접근법(이벤트 방식)으로 동기화 할 수 있다. 지연시간을 감안하면 원격 의존성을 일관성 있는 상태로 유지할 수도 있다. 이는 느슨한 결합, 높은 확장성, 최고의 성능을 가져온다.

메시지 큐 방식의 장점, 이벤트 소싱의 기반, 메시지 큐의 멱등성 (pub-sub 구조에서 메시지를 여러번 읽을 수 있다는 점)

---

## 9. 모듈

이미 개발자라면 모듈과 친숙한 상태다. 다른 이름으로 알고 있을지라도 말이다. 자바에선 이를 패키지라 부르고, C#에선 네임스페이스라 한다. 루비에 언어 구성요소인 모듈을 사용해 클래스의 네임스페이스를 만든다.

모듈의 이름은 유비쿼터스 언어에 맞춰져야한다. 기본적인 DDD 의 목적.

응집도, 낮은 결합도.

---

## 10. 애그리게잇

애그리게잇은 모든 DDD의 전술적인 지침중에서도 무엇보다 정확히 규명되지 않은 패턴 중 하나다.

컴포지션의 편의에 맞춰 설계하다 보면 애그리게잇을 너무 크게 만들어버리는 함정에 빠질 수 있다. 이와 반대로 애그리게잇을 모두 걷어내는 바람에 결과적으로 진정한 고정자를 보호하지 못하는 경우도 있다.

한 트랜잭션 당 한 애그리게잇 인스턴스를 수정하도록 제한하자.

단일 트랜잭션 내에서 완벽한 일관성을 유지하면서, 비즈니스적으로 요구되는 모든 방식과 그 고정자에 맞춰 수정될 수 있어야 한다. 

원자적 일관성과 결과적 일관성은 다르다. 하나의 트랜잭션 내에서 여러 인스턴스를 수정하고 있다면, 일관성 경계가 잘못됐다는 신호일 가능성이 높다.

컴포지션 구조, 그러니 한 로드에 다중 모델들을 로드하는 방향을 지양하자. 애그리게잇을 작게 만든다면 더 좋은 성능으로 이어질 수 있으며 더 나아가 확장성과 분산의 이점도 얻을 수 있다.

직접 관계를 엔터티에서 (여기선 애그리게잇이라 부르는 대상을 엔터티라 하면) 표현하는 게 아닌, (직접참조가 아닌) ID 값 객체등을 통해 참조하면 영속성 상태를 확장을 위해 주변으로 옮겨둘 수 있다.

뷰에서 조합하기 더욱 어려워질 수 있다. 더 많은 레파지토리와 유즈케이스가 추가 될 수 있다. 이는 세타 조인(하이버네이트 참조 조인)이나 CQRS등으로 쿼리 성능 이슈를 해결할 수 있을 것이다.

고정자? 연결을 더 쪼갤 (Id VO 를 따로 두는것 처럼) 이유가 있는지 없는지는 유비쿼터스 언어가 열쇠다. 둘 간의 관계가 어떤 상황마다 항상 의존적이고, 일관성이 유지돼야 한다면 이는 분명한 고정자이다.

하나의 엔터티를 애그리게잇 루트로 모델링하라.
낙관적 동시성을 고려하라.
의존성 주입을 피하라.

---

## 11. 팩토리

팩토리 패턴은 DDD 에 사용되는 패턴 중 그나마 잘 알려진 패턴이다. 추상 팩토리와 팩토리 메서드와 빌더는 디자인 패턴을 통해 널리 알려지게 됐다.

- 복잡한 객체와 애그리게잇 인스턴스를 생서하는 책임을 별도의 객체로 이동시키자. 
- 복잡한 조립과정을 캡슐화하고, 클라이언트가 인스턴화 된 객체의 구체적 클래스를 참조할 필요가 없도록 인터페이스를 제공하자.
- 전체 애그리게잇을 하나의 조각으로 생성하고 고정자를 지정하자

유비쿼터스 언어를 표현하기 적합하다. Forum Entity 하위의 Discussion 이란 하위 엔터티를 생성한다고 가정해보자. 이는 논의를 시작한다는 의미를 표현하고, startDiscussion 과 같은 메서드로 더 의미있게 표현이 가능하다.

애그리게잇의 행동으로서 구현된 여러 메서드를 생성할 수 있다. 사용을 확실히 함으로 민감한 데이터를 더 쉽게 다룰 수 있다.

---

## 12. 리파지토리

이는 영속성과 관련이 있다. 대체로 애그리게잇 타입과 리파지토리 사이에는 일대일의 관계가 성립한다. 그러나 때로 두 개 이상의 애그리게잇 타입이 객체 계층 구조를 공유할 경우에는 하나의 리파지토리를 공유할 수도 있다.

### 컬렉션 지향 리파지토리

전통적인 적븐. 이는 저장소에 저장하거나 영속한다는 생각을 전혀 할 수 없다. (인터페이스를 통한 추상화)

이 저장소는 DB, Session, In-memory 무엇이든 될 수 있다. 

리파지토리 안 메서드들도 유비쿼터스 언어를 반영할 수 있다. 새로운 엔터티 인스턴스를 인스턴스화 하는 책임이 있는 모든 코드를 리파지토리에 적절한 유비쿼터스 언어를 사용해 표현 및 구현하면 된다.

### 영속성 지향의 리파지토리

컬렉션 기반의 스타일이 맞지 않을때는 영송성 지향의 저장기반 리파지토리를 사용해야한다.

- 코히어런스 (정렬들을 기본으로 제공하는 등의 성능 낭비도 아쉽고 최적화 해야할 때)
- 몽고DB 

<가능한 데이터 액세스 지향보단 컬렉션 지향 방식으로 설계하라>

도메인 모델과 이를 둘러싸는 도메인 계층은 트랜잭션을 관리하기에 올바른 장소가 아니다. 일반적으로 애플리케이션 계층에서 관리한다.

주요 유즈케이스 그룹당 하나의 파사드를 애플리케이션 계층에 생성한다. 

애그리게잇은 올바른 일관성 경계를 확보하기 위해 신중하게 설계하는 패턴이다. 트랜잭션을 애플리케이션 단에서 ㄴ남용하면프로덕션 환경에서 동시성 문제로 심각한 상황을 맞을 수 있다.

트랜잭션을 확실하게 보장하기 위서 사용하되, 올바른 일관성 경계를 정의하면 큰 도움을 얻을 수 있다 (10. 애그리게잇)

DAO, Repository 는 보통 동의어로 간주된다. 

DAO 는 데이터베이스 테이블에ㄸ라 표현된다. 보통 테이블 기반의 매퍼로서 존재하는 점이 차이가 있다. 

---

## 13. 바운디드 컨텍스트의 통합

기본적인 통합방법
- API 방식이 있다. (RPC, SOAP, *REST가 아닌*)
- 메시징 매커니즘
- 레스트풀 HTTP

주로 메시징 방식의 구현을 다룸. 느슨한 결합에 더 알맞은 방식. 그러나 구독과 발행을 모두 구현해야 하는 방식.

이 메시징의 발행 기준, 구독의 기준도 필요함. 액션 단위의 토픽, 컨슈머 등의 개념..

---

## 14. 애플리케이션

시스템이나 비즈니스 서비스라는 용어와 애플리케이션이란 용어는 어느정도 대체 가능한 의미로 사용된다.

DTO, DPO (payload object), View model, Presentation Interface 등의 고려

