# IDDD (Implementing domain-driven design) 도메인 주도 개발 설계 구현


## 1. DDD를 시작하며

도메인 전문가는 직책이 아니다. 비즈니스 도메인에 대해 배경지식을 많이 갖고 있는 디자이너거나 영업 인력일 수도 있다. 개발자는 듣을 줄 아는 능력이 필요하다.

도메인 모델이란 구체적인 비즈니스 도메인에 관한 소프트웨어 모델이다. 객체 모델로 종종 구현되는데, 의미를 정확히 부합하는 이름과 데이터, 행동을 담고있다.

DDD 는 비즈니스 전문가 (도메인 전문가) 와 개발자간의 심적 모델을 반영해 개발할 수 있게 해준다. 함께 유비쿼터스 언어를 비즈니스 영역에 적용하며 개발하는 데 힘 쓴다. 초기 비용이 많이들지만 잘 짜여진 팀을 만들고 이는 더욱 팀을 강하게 한다. 비즈니스의 이니셔티브를 다룬다. 기술 분석이 전혀 관련없을 수 없지만 비즈니스의 전략적 설계와 더 가깝다.

* 복잡화하지말고 단순화하자* 이 것이 중요하다. 무기력증으로 인한 기억력 상실 (anemia-induced memory loss) 증상을 겪기 쉽상이다.

수정도, 저장도 맡고 있는 인터페이스를 예로 들어보자. 어떤 값이 변해서 이 인터페이스에 들어왔는지, 수정을 위해서인지 저장을 위해서인지 인터페이스를 통해 알 수 있는 의도가 거의 없다. 이 인터페이스에서 어떤 값이 변했을 때에 대한 조건이 점점 늘어난다면, 복잡도만 점점 늘어날 것이다. 그리고 무엇보다 해당 객체(수정 및 저장 대상)가 사실 전혀 객체가 아니다. 단순 데이터 홀더 정도라고 볼 수 있다.

이는 하나의 메서드(인터페이스) 에서 많은 유즈케이스 플로우나 사용자 스토리를 처리한다. 하나의 ㅐ플리케이션 서비스 메소드가 하나의 유즈케이스만을 위해서 구현되면 어떨까 ?

더 정교하고, 정확하게 비즈니스를 정희하고 이해할 수 있지 않은가? 
더 유요한 도메인 모델을 얻을 수 있지 않은가?

모델 객체를 위해 데이터 접근자만을 노출 시킨다면 그 결과는 단순한 데이터 모델에 가깝게 된다. 데이터 관점의 설계, 게터 및 세터의 무분별한 사용은 도메인 모델을 해친다. 아니, 전혀 도메인 모델이 아니다. 이는 전적으로 클라이언트가 사용방법을 알고 있는지에 달려있다. (유즈케이스가 명확하지 않기때문) 정확한 값을 데이터 모델에 매핑하기 위해 분석을 해야한다. 도메인 비즈니스 가치가 하나도 없다. 그리고 본인도 모르는 사이 너무 많은 선택가능한 옵션을 만들게 된다.

---

## 2. 도메인, 서브도메인, 바운디드 컨텍스트

도메인은 비즈니스의 전체도메인을 말할 수도 있고, 한가지 핵심부분이나 다른 지원분야일 수도 있다. 도메인 모델이란 용어도 도메인이란 용어가 들어있으니 조직의 전체 비즈니스 도메인을 위한 모델이라고 생각할 수 있지만, DDD 에서의 도메인 모델은 오히려 그 반대이다. 조직의 전체 비즈니스 도메인은 여러 서브 도메인으로 이루어져있다. 모델은 바운디드 컨텍스트 안에서 만들어진다. 이 서브도메인은 고유의 핵심 도메인의 일부가 아닌, 일련의 알고리즘과 같은 간단한 형태일 수도 있다.

바운디드 컨텍스트는 주로 유비쿼터스 언어와 그에 해당하는 도메인 모델을 캡슐화한다. ( 도메인 모델과 상호작용, 도메인 모델의 지원을 위해 존재하는 다른 요소도 포함한다. )
모듈, 애그리게잇, 이벤트, 서비스 등 충분할 만큼 포함할 정도로 커야 함.

DDD 에 익숙하지 않은 개발자(나와 같은) 기준에선, 프로젝트 하나의 단위라고 생각하면 좋을 것 같다.
presentation, application, domain(model), infrastructure 의 한 모듈이 하나의 바운디드 컨텍스트, 하나의 팀이 작업해야하는 단위인 것이다.

---

## 3. 컨텍스트 맵

컨텍스트 맵은 바운디드 컨텍스트들 사이의 매핑을 보여주는 단순 다이어그램을 그리는 거라고 볼 수 있다. 이는 엔터프라이즈 아키텍처나 시스템 위상 다이어그램이 아니다. 조직 역학(organizational dynamic)을 보여주는 것이다. 통합의 병목, 아키텍처적 결핍을 강조할 수 있으며, 진행에 걸림돌이 되는 끈적거리는 거버넌스 이슈나 여러 문제를 밝히는 데 도움이 될 수 있다.

adapter, translator(로컬 시스템의 개념으로 변환, 값 객체 및 엔티티로 변환), moderator(xml to json 등 변환) 를 활용한 부패 방지계층 (anticorruption layer, ACL)을 통해 업스트림과 다운스트림의 연결
- REST 기반의 리소스로 구현
- RPC(Remote Procedure Call) API (원격에 위치한 프로그램을 로컬에 있는 프로그램처럼 사용할 수 있다. 개발자는 network 통신과 관련된 작업은 신경쓰지 않아도 된다.)
- 메시지 교환 (MQ 등)

---

## 4. 아키텍처

DDD 는 사실 특정 아키텍처의 사용을 요구하지 않는다. 이게 가장 큰 장점 중 하나라고 한다..

무엇이든 규모에 맞는 아키텍처가 제일 중요하다. 다만 책에 나온 사스오베이션의 일화를 보면 확장성 있게 코드베이스를 다지고, 그를 기반으로 아키텍처를 변화시키면 될 것 같다. CQRS, event sourcing, Hexagonal .. 등등

- 전통적인 DDD 계층 아키텍처 <UI(presentation) - Application - Domain - Infrastructure>
  - 바로 아래층과만 연결되도록 하는 엄격한 (strict) 계층도 있지만 보통 어플리케이션과 UI에서 인프라계층을 이용하기 때문에 느슨한 (relaxed) 계층을 기반으로 한다
  - DIP 의 활용
  - 도메인 로직이 애플리케이션 서비스로 새어나가지 않아야함. 모델이 무력해지면 안됨
- 헥사고날 또는 포트와 어댑터
  - 대부분의 계층형 아키텍처를 사용하는 곳에서 헥사고날이 녹아있다. DIP 의 사용이기때문에 포트 어댑터 스타일의 방향으로 흘러가는 것
  - 프론트엔드와 백엔드라고 여기는 게 아닌 다른 방식으로 바라본다. 각 클라이언트 타입<HTTP, AMQP(rabbit mq 와 같은)>이 자신의 고유한 어댑터를 갖는다. 이 어댑터가 애플리케이션과 호환되는 내부 입력으로 변환한다
- 서비스 지향 
- CQRS
  - DomainEventPublisher (옵저버 패턴에 기반한 경량 컴포넌트)
- 파이프와 필터 패턴, 이벤트 소싱 등 이벤트 주도 방식

---

## 5. 엔티티

개발자는 도메인보다 데이터에 초점을 맞추려는 경향이 있다. 대부분 데이터베이스 중점으로 사고하기때문에 DDD 를 처음 경험하는 개발자에겐 흔히 일어날 수 있는 현상이다.

유비쿼터스 언어를 활용해 행동을 끌어내야한다. 행동을 먼저 정의하고 그를 통해 연결관계를 이끌어내자. 너무 구체적이지 않은 상태를 바탕으로 관계를 통해 객체를 모델링하자.

식별자를 찾아내자. (대리식별자: 기본적인 auto increment PK. id, no 따위의 컬럼) 도메인 식별자가 굳이 기본키가 될 필요는 없다. 두 값이 합쳐진 복합 유니크 키와 같은 형태도 될 수 있다.
식별자가 값 객체로 모델링 되는 이유는 단순 String (UUID) 따위의 문자 표현일지라도 광범위하게 사용될 수 있기 때문이다. 더 강한 타입으로 지정한다는 의미이다.

(좀 더 작은 단위로 역할 인터페이스를 만드는 방법도 고려해보자)

엔티티를 생성시엔 팩토리를 사용해보자.
엔티티 생성시 유효성 검사등은 Validator 클래스등을 명세패턴이나 전략패턴을 통해 구현하자. (Base Entity class 에 validate 메서드를 overide 하고, 유효성 검사 명세를 파라미터로 넘겨주는 등)

도메인 엔티티에 대한 변경사항 추적은 도메인 이벤트와 이벤트 저장소를 통해 확인하자. (이벤트소싱과 같은 패턴을 통해)

---

## 6. 값 객체


엔티티에 대한 고민에 가려지지만, 값 객체는 DDD 에 필수 구성요소다. 값 타입을 생성하는 일은 쉽지만, DDD에 경험이 없다면 특정 인스턴스 내에서 엔티티로 모델링할지, 값으로 모델링할지는 상당히 혼란스러울 수 있다.

_특징_

- 도메인 내의 어떤 대상을 측정하고 수량화하고 설명한다.
  - 값 객체는 도메인 안에 있지 않다.  이는 도메인 내에 있는 어떤 대상을 측정하고 수량화하고 설명하는 개념이다. 사람에겐 나이와 이름이 있다. 이는 실재하지 않지만 측정하고 수량화하며 이를 설명한다.
  - 개념적 전체
- 불변성
  - 생성되면 변경할 수 없다.
- 관련 특성을 모은 필수 단위로 개념적 전체를 모델링한다.
  - 응집력 
- 측정이나 설명이 변경될 땐 완벽히 대체 가능하다.
  - 불변성, 새 객체 
- 다른 값과 등가성을 사용해 비교할 수 있다.
  - equals(), hashCode() 
- 협력자에게 부작용이 없는 행동을 제공한다.
  - 값 객체에 변화를 주지 않는 함수는 가질 수 있다.

---

## 7. 서비스

도메인 내에서 서비스란 도메인 고유의 작업을 수행하는 무상태의 오퍼레이션이다. 서비스가 필요하다는 지표는 애그리게잇이나 값 객체 상에서 수행해야하는 오퍼레이션이 메소드로는 부적절하다고 느껴질때다.

도메인 서비스와 애플리케이션 서비스를 혼동해서는 안 된다.

---


